package io.netflow.flows

import io.wasted.util._

import org.joda.time.DateTime
import java.net.{ InetAddress, InetSocketAddress }

private[netflow] class FlowException(msg: String) extends Exception(msg)

private[netflow] trait FlowPacket {
  def version: String
  def sender: InetSocketAddress
  def senderIP = sender.getAddress.getHostAddress
  def senderPort = sender.getPort

  def count: Int
  def uptime: Long
  def date: DateTime
  def flows: Vector[Flow]
}

private[netflow] trait Flow {
  def version: String
}

private[netflow] trait JsonFlowData {
  def json: String
}

/**
 * Accounting statistics for InetAddress and Networks generated by NetFlow.
 */
private[netflow] case class IPFlowData(
  version: String,
  sender: InetSocketAddress,
  srcPort: Int,
  dstPort: Int,
  srcAS: Int,
  dstAS: Int,
  srcAddress: InetAddress,
  dstAddress: InetAddress,
  nextHop: InetAddress,
  pkts: Long,
  bytes: Long,
  proto: Int,
  tos: Int,
  length: Int) extends JsonFlowData with Flow {
  def senderIP = sender.getAddress.getHostAddress
  def senderPort = sender.getPort

  override def toString() = "%s from %s/%s %s:%s (%s) -> %s -> %s:%s (%s) Proto %s - ToS %s - %s pkts - %s bytes".format(
    version, senderIP, senderPort, srcAddress.getHostAddress, srcPort, srcAS,
    nextHop.getHostAddress, dstAddress.getHostAddress, dstPort, dstAS, proto, tos, pkts, bytes)

  private def srcAddressIP() = srcAddress.getHostAddress
  private def dstAddressIP() = dstAddress.getHostAddress
  private def nextHopIP() = nextHop.getHostAddress

  lazy val json = """
    {
      "flowVersion": "%s",
      "flowSender": "%s/%s",
      "srcPort": %s,
      "dstPort": %s,
      "srcAddress": "%s",
      "dstAddress": "%s",
      "srcAS": %s,
      "dstAS": %s,
      "nextHop": "%s",
      "proto": %s,
      "tos": %s,
      "pkts": %s,
      "bytes": %s
    }""".trim().format(
    version, senderIP, senderPort, srcPort, dstPort, srcAddressIP, dstAddressIP,
    srcAS, dstAS, nextHopIP, proto, tos, pkts, bytes)
}

/**
 * Interface statistics generated by sFlow.
 */
private[netflow] case class IFFlowData(
  version: String,
  sender: InetSocketAddress,
  length: Int) extends JsonFlowData with Flow {
  def senderIP = sender.getAddress.getHostAddress
  def senderPort = sender.getPort

  override def toString() = "%s from %s/%s".format(version, senderIP, senderPort)

  lazy val json = """
    {
      "flowVersion": "%s",
      "flowSender": "%s/%s"
    }""".trim().format(version, senderIP, senderPort)
}

